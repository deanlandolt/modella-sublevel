# modella-sublevel

Modella plugin to attach a model to a `sublevel`-based backing store, with optional secondary indexing.

## Usage

```js
var sublevel = require('modella-sublevel')

// assuming your db is in scope
var myStore = db.sublevel('MyModel')

var MyModel = model('MyModel')
  .use(sublevel(store))

  // primary key field required (defaults to `id` or `_id` attr per modella API
  .attr('mykey', {
    primaryKey: true
  })

  // unindexed attribute
  .attr('somefield', {
    defaultValue: 'xxx'
  })

  // explicitly indexed field
  .attr('anotherfield', {
    index: true
  })

  // unique fields are implicitly implicitly indexed to verify uniqueness
  .attr('uniquefield', {
    unique: true
  })

// sublevel is available on the `store` key
MyModel.store === myStore

// sublevel methods overriden to do model validation
myStore.put('a', {
  // unique fields are implicitly `required: true`
  uniquefield: 'foo'
}, function (err, record) {
  // sublevel write methods return JSON of created instance
  record.key === 'a'

  // this includes any properties generated by model instantiation
  record.somefield === 'xxx'
})

// convenience methods available on model to interface with store using models
MyModel.create({
  mykey: 'b',
  uniquefield: 'bar'
}, function (err, model) {
  // callback is invoked with a model instance
  model.somefield('yyy')

  // `save` available as an instance method to write back to store
  model.save(function (err, model_) {
    // save returns same model instance
    model === model_
  })
})
```

### Lazy initialization

You may not have a database reference available when creating your model. Rather than invoking with a database reference, the module can be passed as the modella plugin. An `attach` method is added to the model which can be provided the sublevel backing store when available:

```js
var OtherModel = model('OtherModel')
  .use(sublevel)
  .attr('id')

OtherModel.store === undefined
```

// some time later...
var otherStore = db.sublevel('OtherModel')
OtherModel.attach(otherStore)
OtherModel.store === otherStore
```

### Detaching a store

The `attach` method can be called without a store reference to detach it from store:

```
OtherModel.attach()
OtherModel.store === undefined
```

When detaching, any methods overwritten on the backing store instance will be replaced with their original versions.
